from typing import List
import numpy as np
from scipy.constants import mu_0, pi

from src.fields import VectorField

class BiotSavartEquationSolver:
    """
    A Biot–Savart law solver used to compute the resultant magnetic field B in 2D-space generated by a constant current
    field I (for example due to wires).
    """
    
    def solve(electric_current: VectorField) -> VectorField:
        """
        Solve the Biot–Savart equation to compute the magnetic field given an electric current field.

        Parameters
        ----------
        electric_current : VectorField
            A vector field I : ℝ² → ℝ³ ; (x, y) → (I_x(x, y), I_y(x, y), I_z(x, y)), where I_x(x, y), I_y(x, y) and
            I_z(x, y) are the 3 components of the electric current vector at a given point (x, y) in space. Note that
            I_z = 0 is always True in our 2D world.

        Returns
        -------
        magnetic_field : VectorField
            A vector field B : ℝ² → ℝ³ ; (x, y) → (B_x(x, y), B_y(x, y), B_z(x, y)), where B_x(x, y), B_y(x, y) and
            B_z(x, y) are the 3 components of the magnetic vector at a given point (x, y) in space. Note that
            B_x = B_y = 0 is always True in our 2D world.
        """
        
        #Faire un array avec les position en x
        X1 = np.ones(electric_current.shape[1])
        for i in range(len(X1)):
            X1[i] = i+1
        X = X1
        for _ in range(electric_current.shape[0]-1):
            X = np.vstack([X1,X])

        #Faire un array avec les position en y
        Y1 = np.ones((electric_current.shape[0],1))
        for i in range(len(Y1)):
            Y1[i] = i+1
        Y = Y1
        for _ in range(electric_current.shape[1]-1):
            Y = np.hstack([Y1,Y])


        # faire un array 2D de la même dimension que la grille
        Bz = np.zeros((electric_current.shape[0], electric_current.shape[1]))

        for iy, row in enumerate(electric_current):
            for ix, current in enumerate(row):
                if np.linalg.norm(current) != 0:
                    VecX = X - (ix+1)                       #champs scalaire de la composante x des vecteurs r pour chaque point
                    VecY = Y - (iy+1)                          #champs scalaire de la composante y des vecteurs r pour chaque point

                    dB = current[1]*VecY - current[0]*VecX      #A x B = ... + (Ax*By - Ay*Bx )k
                                                                #Pour une raison étrange, la composante en x du courant est à l'indice [1], et celle en y au [0]

                    dB /= np.nan_to_num(-(VecX**2+VecY**2) ** (3/2), nan=0 ) #Il faut ajouter un facteur -1 pour ob=btenir le bon résultat...
                                                                            #la fonction nan_to_num permet de retirer les valeurs présente dans les fils 

                    Bz += dB            # On discretise l'intégrale de B en sommant les dB
        Bz *= mu_0 / (4* pi)

        #Mettre Bz dans un champs vectoriel B
        B = []
        for iy ,row in enumerate(Bz):
            Brow = []
            for ix, pt in enumerate(row):
                Brow += [[0, 0, pt]]
            B += [Brow]
        
        B = VectorField(np.array(B))

        return B
